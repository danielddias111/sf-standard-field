export declare type LogicalOperator = 'AND' | 'OR' | 'NOT';
export declare type Operator = '=' | '!=' | '<=' | '>=' | '>' | '<' | 'LIKE' | 'IN' | 'NOT IN' | 'INCLUDES' | 'EXCLUDES';
export declare type FieldTypeOfConditionType = 'WHEN' | 'ELSE';
export declare type GroupSelector = 'ABOVE' | 'AT' | 'BELOW' | 'ABOVE_OR_BELOW';
export declare type ForClause = 'VIEW' | 'UPDATE' | 'REFERENCE';
export declare type UpdateClause = 'TRACKING' | 'VIEWSTAT';
export declare type LiteralType = 'STRING' | 'INTEGER' | 'DECIMAL' | 'INTEGER_WITH_CURRENCY_PREFIX' | 'DECIMAL_WITH_CURRENCY_PREFIX' | 'BOOLEAN' | 'NULL' | 'DATETIME' | 'DATE' | 'DATE_LITERAL' | 'DATE_N_LITERAL' | 'APEX_BIND_VARIABLE';
export declare type FieldType = Field | FieldWithAlias | FieldFunctionExpression | FieldRelationship | FieldRelationshipWithAlias | FieldSubquery | FieldTypeOf;
export declare type OrderByCriterion = 'ASC' | 'DESC';
export declare type NullsOrder = 'FIRST' | 'LAST';
export declare type GroupByType = 'CUBE' | 'ROLLUP';
export declare type DateLiteral = 'YESTERDAY' | 'TODAY' | 'TOMORROW' | 'LAST_WEEK' | 'THIS_WEEK' | 'NEXT_WEEK' | 'LAST_MONTH' | 'THIS_MONTH' | 'NEXT_MONTH' | 'LAST_90_DAYS' | 'NEXT_90_DAYS' | 'THIS_QUARTER' | 'LAST_QUARTER' | 'NEXT_QUARTER' | 'THIS_YEAR' | 'LAST_YEAR' | 'NEXT_YEAR' | 'THIS_FISCAL_QUARTER' | 'LAST_FISCAL_QUARTER' | 'NEXT_FISCAL_QUARTER' | 'THIS_FISCAL_YEAR' | 'LAST_FISCAL_YEAR' | 'NEXT_FISCAL_YEAR';
export declare type DateNLiteral = 'YESTERDAY' | 'NEXT_N_DAYS' | 'LAST_N_DAYS' | 'N_DAYS_AGO' | 'NEXT_N_WEEKS' | 'LAST_N_WEEKS' | 'N_WEEKS_AGO' | 'NEXT_N_MONTHS' | 'LAST_N_MONTHS' | 'N_MONTHS_AGO' | 'NEXT_N_QUARTERS' | 'LAST_N_QUARTERS' | 'N_QUARTERS_AGO' | 'NEXT_N_YEARS' | 'LAST_N_YEARS' | 'N_YEARS_AGO' | 'NEXT_N_FISCAL_QUARTERS' | 'LAST_N_FISCAL_QUARTERS' | 'N_FISCAL_QUARTERS_AGO' | 'NEXT_N_FISCAL_YEARS' | 'LAST_N_FISCAL_YEARS' | 'N_FISCAL_YEARS_AGO';
export interface Field {
    type: 'Field';
    field: string;
    alias?: string;
}
export interface FieldWithAlias extends Field {
    objectPrefix: string;
    rawValue: string;
}
export interface FieldFunctionExpression {
    type: 'FieldFunctionExpression';
    functionName: string;
    parameters: (string | FieldFunctionExpression)[];
    alias?: string;
    isAggregateFn?: boolean;
    rawValue?: string;
}
export interface FieldRelationship {
    type: 'FieldRelationship';
    field: string;
    relationships: string[];
    rawValue?: string;
}
export interface FieldRelationshipWithAlias extends FieldRelationship {
    objectPrefix: string;
    alias: string;
}
export interface FieldSubquery {
    type: 'FieldSubquery';
    subquery: Subquery;
}
export interface FieldTypeOf {
    type: 'FieldTypeof';
    field: string;
    conditions: FieldTypeOfCondition[];
}
export interface FieldTypeOfCondition {
    type: FieldTypeOfConditionType;
    objectType?: string;
    fieldList: string[];
}
export interface QueryBase {
    fields: FieldType[];
    sObjectAlias?: string;
    usingScope?: string;
    where?: WhereClause;
    limit?: number;
    offset?: number;
    groupBy?: GroupByClause | GroupByClause[];
    having?: HavingClause;
    orderBy?: OrderByClause | OrderByClause[];
    withDataCategory?: WithDataCategoryClause;
    withSecurityEnforced?: boolean;
    for?: ForClause;
    update?: UpdateClause;
}
export interface Query extends QueryBase {
    sObject: string;
}
export interface Subquery extends QueryBase {
    relationshipName: string;
    sObjectPrefix?: string[];
}
export declare type WhereClause = WhereClauseWithoutOperator | WhereClauseWithRightCondition;
export interface WhereClauseWithoutOperator {
    left: ConditionWithValueQuery;
}
export interface WhereClauseWithRightCondition extends WhereClauseWithoutOperator {
    operator: LogicalOperator;
    right: WhereClause;
}
export declare type Condition = ValueCondition | ValueWithDateLiteralCondition | ValueWithDateNLiteralCondition | ValueFunctionCondition | NegationCondition;
export declare type ConditionWithValueQuery = Condition | ValueQueryCondition;
export interface OptionalParentheses {
    openParen?: number;
    closeParen?: number;
}
export interface ValueCondition extends OptionalParentheses {
    field: string;
    operator: Operator;
    value: string | string[];
    literalType?: LiteralType | LiteralType[];
}
export interface ValueWithDateLiteralCondition extends OptionalParentheses {
    field: string;
    operator: Operator;
    value: DateLiteral | DateLiteral[];
    literalType?: 'DATE_LITERAL' | 'DATE_LITERAL'[];
}
export interface ValueWithDateNLiteralCondition extends OptionalParentheses {
    field: string;
    operator: Operator;
    value: string | string[];
    literalType?: 'DATE_N_LITERAL' | 'DATE_N_LITERAL'[];
    dateLiteralVariable: number | number[];
}
export interface ValueQueryCondition extends OptionalParentheses {
    field: string;
    operator: Operator;
    valueQuery: Query;
}
export interface ValueFunctionCondition extends OptionalParentheses {
    fn: FunctionExp;
    operator: Operator;
    value: string | string[];
    literalType?: LiteralType | LiteralType[];
}
export interface NegationCondition {
    openParen: number;
}
export declare type OrderByClause = OrderByFieldClause | OrderByFnClause;
export interface OrderByOptionalFieldsClause {
    order?: OrderByCriterion;
    nulls?: NullsOrder;
}
export interface OrderByFieldClause extends OrderByOptionalFieldsClause {
    field: string;
}
export interface OrderByFnClause extends OrderByOptionalFieldsClause {
    fn: FunctionExp;
}
export declare type GroupByClause = GroupByFieldClause | GroupByFnClause;
export interface GroupByFieldClause {
    field: string;
}
export interface GroupByFnClause {
    fn: FunctionExp;
}
export declare type HavingClause = HavingClauseWithoutOperator | HavingClauseWithRightCondition;
export interface HavingClauseWithoutOperator {
    left: Condition;
}
export interface HavingClauseWithRightCondition extends HavingClauseWithoutOperator {
    operator: LogicalOperator;
    right: HavingClause;
}
export interface FunctionExp {
    rawValue?: string;
    functionName?: string;
    alias?: string;
    parameters?: (string | FunctionExp)[];
    isAggregateFn?: boolean;
}
export interface WithDataCategoryClause {
    conditions: WithDataCategoryCondition[];
}
export interface WithDataCategoryCondition {
    groupName: string;
    selector: GroupSelector;
    parameters: string[];
}
