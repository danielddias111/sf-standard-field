"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFlattenedFields = exports.getField = exports.getComposedField = exports.isWhereOrHavingClauseWithRightCondition = exports.isWhereClauseWithRightCondition = exports.isValueWithDateNLiteralCondition = exports.isValueWithDateLiteralCondition = exports.isValueQueryCondition = exports.isValueFunctionCondition = exports.isValueCondition = exports.isSubquery = exports.isString = exports.isOrderByFn = exports.isOrderByField = exports.isNegationCondition = exports.isHavingClauseWithRightCondition = exports.isGroupByFn = exports.isGroupByField = exports.isFieldSubquery = exports.hasAlias = void 0;
var utils_1 = require("../utils");
Object.defineProperty(exports, "hasAlias", { enumerable: true, get: function () { return utils_1.hasAlias; } });
Object.defineProperty(exports, "isFieldSubquery", { enumerable: true, get: function () { return utils_1.isFieldSubquery; } });
Object.defineProperty(exports, "isGroupByField", { enumerable: true, get: function () { return utils_1.isGroupByField; } });
Object.defineProperty(exports, "isGroupByFn", { enumerable: true, get: function () { return utils_1.isGroupByFn; } });
Object.defineProperty(exports, "isHavingClauseWithRightCondition", { enumerable: true, get: function () { return utils_1.isHavingClauseWithRightCondition; } });
Object.defineProperty(exports, "isNegationCondition", { enumerable: true, get: function () { return utils_1.isNegationCondition; } });
Object.defineProperty(exports, "isOrderByField", { enumerable: true, get: function () { return utils_1.isOrderByField; } });
Object.defineProperty(exports, "isOrderByFn", { enumerable: true, get: function () { return utils_1.isOrderByFn; } });
Object.defineProperty(exports, "isString", { enumerable: true, get: function () { return utils_1.isString; } });
Object.defineProperty(exports, "isSubquery", { enumerable: true, get: function () { return utils_1.isSubquery; } });
Object.defineProperty(exports, "isValueCondition", { enumerable: true, get: function () { return utils_1.isValueCondition; } });
Object.defineProperty(exports, "isValueFunctionCondition", { enumerable: true, get: function () { return utils_1.isValueFunctionCondition; } });
Object.defineProperty(exports, "isValueQueryCondition", { enumerable: true, get: function () { return utils_1.isValueQueryCondition; } });
Object.defineProperty(exports, "isValueWithDateLiteralCondition", { enumerable: true, get: function () { return utils_1.isValueWithDateLiteralCondition; } });
Object.defineProperty(exports, "isValueWithDateNLiteralCondition", { enumerable: true, get: function () { return utils_1.isValueWithDateNLiteralCondition; } });
Object.defineProperty(exports, "isWhereClauseWithRightCondition", { enumerable: true, get: function () { return utils_1.isWhereClauseWithRightCondition; } });
Object.defineProperty(exports, "isWhereOrHavingClauseWithRightCondition", { enumerable: true, get: function () { return utils_1.isWhereOrHavingClauseWithRightCondition; } });
function getComposedField(input) {
    return getField(input);
}
exports.getComposedField = getComposedField;
function getField(input) {
    if (typeof input === 'string') {
        return {
            type: 'Field',
            field: input,
        };
    }
    else if (utils_1.isComposeFieldFunction(input)) {
        var parameters = void 0;
        if (input.parameters) {
            parameters = (Array.isArray(input.parameters) ? input.parameters : [input.parameters]);
        }
        return {
            type: 'FieldFunctionExpression',
            functionName: input.functionName || input.fn,
            parameters: parameters,
            alias: input.alias,
        };
    }
    else if (utils_1.isComposeFieldRelationship(input)) {
        return {
            type: 'FieldRelationship',
            field: input.field,
            relationships: input.relationships,
            objectPrefix: input.objectPrefix,
        };
    }
    else if (utils_1.isComposeFieldSubquery(input)) {
        return {
            type: 'FieldSubquery',
            subquery: input.subquery,
        };
    }
    else if (utils_1.isComposeFieldTypeof(input)) {
        return {
            type: 'FieldTypeof',
            field: input.field,
            conditions: input.conditions,
        };
    }
    else if (utils_1.isComposeField(input)) {
        return {
            type: 'Field',
            field: input.field,
            objectPrefix: input.objectPrefix,
        };
    }
    else {
        throw new TypeError('The input object provided did not match any valid field types');
    }
}
exports.getField = getField;
function getFlattenedFields(query, isAggregateResult) {
    if (!query) {
        return [];
    }
    query = utils_1.isFieldSubquery(query) ? query.subquery : query;
    var fields = query.fields;
    var groupByFields = {};
    if (!!query.groupBy) {
        groupByFields = (Array.isArray(query.groupBy) ? query.groupBy : [query.groupBy]).reduce(function (output, clause) {
            if (utils_1.isGroupByField(clause)) {
                output[clause.field.toLocaleLowerCase()] = clause.field;
            }
            return output;
        }, {});
    }
    var currUnAliasedAggExp = -1;
    var sObject = (utils_1.isSubquery(query) ? query.relationshipName : query.sObject || '').toLowerCase();
    var sObjectAlias = (query.sObjectAlias || '').toLowerCase();
    var parsedFields = fields
        .flatMap(function (field) {
        switch (field.type) {
            case 'Field': {
                return field.field;
            }
            case 'FieldFunctionExpression': {
                var params = utils_1.getParams(field);
                params = params.map(function (param) {
                    if (param.includes('.')) {
                        var tempParams = param.split('.');
                        var firstParam = tempParams[0].toLowerCase();
                        if (firstParam === sObjectAlias || firstParam === sObject) {
                            tempParams = tempParams.slice(1);
                        }
                        return tempParams.join('.');
                    }
                    return param;
                });
                if (field.alias && (field.isAggregateFn || isAggregateResult)) {
                    return field.alias;
                }
                if (field.alias) {
                    var firstParam = params[0];
                    if (firstParam.includes('.')) {
                        params = firstParam.split('.').slice(0, -1);
                        params.push(field.alias);
                        return params.join('.');
                    }
                    return field.alias;
                }
                if (field.isAggregateFn || isAggregateResult) {
                    currUnAliasedAggExp++;
                    return "expr" + currUnAliasedAggExp;
                }
                if (params.length > 0) {
                    return params.join('.');
                }
                return field.functionName;
            }
            case 'FieldRelationship': {
                var firstRelationship = field.relationships[0].toLowerCase();
                if (utils_1.hasAlias(field)) {
                    return field.alias;
                }
                if (field.rawValue && groupByFields[field.rawValue.toLocaleLowerCase()]) {
                    return field.field;
                }
                if (firstRelationship === sObjectAlias || firstRelationship === sObject) {
                    return field.relationships.concat([field.field]).slice(1).join('.');
                }
                return field.relationships.concat([field.field]).join('.');
            }
            case 'FieldSubquery': {
                return field.subquery.relationshipName;
            }
            case 'FieldTypeof': {
                var priorFields_1 = new Set();
                var fields_1 = [];
                field.conditions.forEach(function (condition) {
                    condition.fieldList.forEach(function (currField) {
                        if (!priorFields_1.has(currField)) {
                            priorFields_1.add(currField);
                            fields_1.push(field.field + "." + currField);
                        }
                    });
                });
                return fields_1;
            }
            default:
                break;
        }
    })
        .filter(function (field) { return utils_1.isString(field); });
    return parsedFields;
}
exports.getFlattenedFields = getFlattenedFields;
//# sourceMappingURL=public-utils.js.map