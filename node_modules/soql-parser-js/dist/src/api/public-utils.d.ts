import { hasAlias, isFieldSubquery, isGroupByField, isGroupByFn, isHavingClauseWithRightCondition, isNegationCondition, isOrderByField, isOrderByFn, isString, isSubquery, isValueCondition, isValueFunctionCondition, isValueQueryCondition, isValueWithDateLiteralCondition, isValueWithDateNLiteralCondition, isWhereClauseWithRightCondition, isWhereOrHavingClauseWithRightCondition } from '../utils';
import * as SoqlModels from './api-models';
export { hasAlias, isFieldSubquery, isGroupByField, isGroupByFn, isHavingClauseWithRightCondition, isNegationCondition, isOrderByField, isOrderByFn, isString, isSubquery, isValueCondition, isValueFunctionCondition, isValueQueryCondition, isValueWithDateLiteralCondition, isValueWithDateNLiteralCondition, isWhereClauseWithRightCondition, isWhereOrHavingClauseWithRightCondition, };
export declare type ComposeFieldInput = ComposeField | ComposeFieldFunction | ComposeFieldRelationship | ComposeFieldSubquery | ComposeFieldTypeof;
export interface ComposeField {
    field: string;
    objectPrefix?: string;
}
export interface ComposeFieldFunction {
    fn?: string;
    functionName: string;
    parameters?: string | SoqlModels.FieldFunctionExpression | (string | SoqlModels.FieldFunctionExpression)[];
    alias?: string;
}
export interface ComposeFieldRelationship {
    field: string;
    relationships: string[];
    objectPrefix?: string;
}
export interface ComposeFieldSubquery {
    subquery?: SoqlModels.Subquery;
}
export interface ComposeFieldTypeof {
    field: string;
    conditions: SoqlModels.FieldTypeOfCondition[];
}
export declare function getComposedField(input: string | ComposeFieldInput): SoqlModels.FieldType;
export declare function getField(input: string | ComposeFieldInput): SoqlModels.FieldType;
export declare function getFlattenedFields(query: SoqlModels.Query | SoqlModels.Subquery | SoqlModels.FieldSubquery, isAggregateResult?: boolean): string[];
