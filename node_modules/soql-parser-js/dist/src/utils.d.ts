import { IToken } from 'chevrotain';
import { FieldFunctionExpression, FieldRelationshipWithAlias, FieldSubquery, FieldWithAlias, GroupByFieldClause, GroupByFnClause, HavingClauseWithRightCondition, LiteralType, NegationCondition, OrderByFieldClause, OrderByFnClause, Query, Subquery, ValueCondition, ValueFunctionCondition, ValueQueryCondition, ValueWithDateLiteralCondition, ValueWithDateNLiteralCondition, WhereClauseWithRightCondition } from './api/api-models';
import { ComposeField, ComposeFieldFunction, ComposeFieldRelationship, ComposeFieldSubquery, ComposeFieldTypeof } from './api/public-utils';
export declare function isToken(val: any): val is IToken[] | IToken;
export declare function isSubqueryFromFlag(val: any, isSubquery: boolean): val is Subquery;
export declare function isString(val: any): val is string;
export declare function isStringArray(val: any[]): val is string[];
export declare function isNumber(val: any): val is number;
export declare function isBoolean(val: any): val is boolean;
export declare function isObject(val: any): val is any;
export declare function isNil(val: any): val is null | undefined;
export declare function get(val: string | null | undefined, suffix?: string, prefix?: string): string;
export declare function getIfTrue(val: boolean | null | undefined, returnStr: string): string;
export declare function getLastItem<T>(arr: T[]): T;
export declare function getAsArrayStr(val: string | string[], alwaysParens?: boolean): string;
export declare function pad(val: string, len: number, left?: number): string;
export declare function generateParens(count: number, character: '(' | ')', joinCharacter?: string): string;
export declare function getParams(functionFieldExp: FieldFunctionExpression): string[];
export declare function hasAlias(value: any): value is FieldWithAlias | FieldRelationshipWithAlias;
export declare function isComposeField(input: any): input is ComposeField;
export declare function isComposeFieldFunction(input: any): input is ComposeFieldFunction;
export declare function isComposeFieldRelationship(input: any): input is ComposeFieldRelationship;
export declare function isComposeFieldSubquery(input: any): input is ComposeFieldSubquery;
export declare function isComposeFieldTypeof(input: any): input is ComposeFieldTypeof;
export declare function isSubquery(query: Query | Subquery): query is Subquery;
export declare function isFieldSubquery(value: any): value is FieldSubquery;
export declare function isWhereClauseWithRightCondition(value: any): value is WhereClauseWithRightCondition;
export declare function isHavingClauseWithRightCondition(value: any): value is HavingClauseWithRightCondition;
export declare function isWhereOrHavingClauseWithRightCondition(value: any): value is WhereClauseWithRightCondition | HavingClauseWithRightCondition;
export declare function isValueCondition(value: any): value is ValueCondition;
export declare function isValueWithDateLiteralCondition(value: any): value is ValueWithDateLiteralCondition;
export declare function isValueWithDateNLiteralCondition(value: any): value is ValueWithDateNLiteralCondition;
export declare function isValueFunctionCondition(value: any): value is ValueFunctionCondition;
export declare function isNegationCondition(value: any): value is NegationCondition;
export declare function isValueQueryCondition(value: any): value is ValueQueryCondition;
export declare function isOrderByField(value: any): value is OrderByFieldClause;
export declare function isOrderByFn(value: any): value is OrderByFnClause;
export declare function isGroupByField(value: any): value is GroupByFieldClause;
export declare function isGroupByFn(value: any): value is GroupByFnClause;
export declare function getWhereValue(value: any | any[], literalType?: LiteralType | LiteralType[]): any;
