import { getParams, hasAlias, isComposeField, isComposeFieldFunction, isComposeFieldRelationship, isComposeFieldSubquery, isComposeFieldTypeof, isFieldSubquery, isGroupByField, isGroupByFn, isHavingClauseWithRightCondition, isNegationCondition, isOrderByField, isOrderByFn, isString, isSubquery, isValueCondition, isValueFunctionCondition, isValueQueryCondition, isValueWithDateLiteralCondition, isValueWithDateNLiteralCondition, isWhereClauseWithRightCondition, isWhereOrHavingClauseWithRightCondition, } from '../utils';
export { hasAlias, isFieldSubquery, isGroupByField, isGroupByFn, isHavingClauseWithRightCondition, isNegationCondition, isOrderByField, isOrderByFn, isString, isSubquery, isValueCondition, isValueFunctionCondition, isValueQueryCondition, isValueWithDateLiteralCondition, isValueWithDateNLiteralCondition, isWhereClauseWithRightCondition, isWhereOrHavingClauseWithRightCondition, };
export function getComposedField(input) {
    return getField(input);
}
export function getField(input) {
    if (typeof input === 'string') {
        return {
            type: 'Field',
            field: input,
        };
    }
    else if (isComposeFieldFunction(input)) {
        var parameters = void 0;
        if (input.parameters) {
            parameters = (Array.isArray(input.parameters) ? input.parameters : [input.parameters]);
        }
        return {
            type: 'FieldFunctionExpression',
            functionName: input.functionName || input.fn,
            parameters: parameters,
            alias: input.alias,
        };
    }
    else if (isComposeFieldRelationship(input)) {
        return {
            type: 'FieldRelationship',
            field: input.field,
            relationships: input.relationships,
            objectPrefix: input.objectPrefix,
        };
    }
    else if (isComposeFieldSubquery(input)) {
        return {
            type: 'FieldSubquery',
            subquery: input.subquery,
        };
    }
    else if (isComposeFieldTypeof(input)) {
        return {
            type: 'FieldTypeof',
            field: input.field,
            conditions: input.conditions,
        };
    }
    else if (isComposeField(input)) {
        return {
            type: 'Field',
            field: input.field,
            objectPrefix: input.objectPrefix,
        };
    }
    else {
        throw new TypeError('The input object provided did not match any valid field types');
    }
}
export function getFlattenedFields(query, isAggregateResult) {
    if (!query) {
        return [];
    }
    query = isFieldSubquery(query) ? query.subquery : query;
    var fields = query.fields;
    var groupByFields = {};
    if (!!query.groupBy) {
        groupByFields = (Array.isArray(query.groupBy) ? query.groupBy : [query.groupBy]).reduce(function (output, clause) {
            if (isGroupByField(clause)) {
                output[clause.field.toLocaleLowerCase()] = clause.field;
            }
            return output;
        }, {});
    }
    var currUnAliasedAggExp = -1;
    var sObject = (isSubquery(query) ? query.relationshipName : query.sObject || '').toLowerCase();
    var sObjectAlias = (query.sObjectAlias || '').toLowerCase();
    var parsedFields = fields
        .flatMap(function (field) {
        switch (field.type) {
            case 'Field': {
                return field.field;
            }
            case 'FieldFunctionExpression': {
                var params = getParams(field);
                params = params.map(function (param) {
                    if (param.includes('.')) {
                        var tempParams = param.split('.');
                        var firstParam = tempParams[0].toLowerCase();
                        if (firstParam === sObjectAlias || firstParam === sObject) {
                            tempParams = tempParams.slice(1);
                        }
                        return tempParams.join('.');
                    }
                    return param;
                });
                if (field.alias && (field.isAggregateFn || isAggregateResult)) {
                    return field.alias;
                }
                if (field.alias) {
                    var firstParam = params[0];
                    if (firstParam.includes('.')) {
                        params = firstParam.split('.').slice(0, -1);
                        params.push(field.alias);
                        return params.join('.');
                    }
                    return field.alias;
                }
                if (field.isAggregateFn || isAggregateResult) {
                    currUnAliasedAggExp++;
                    return "expr" + currUnAliasedAggExp;
                }
                if (params.length > 0) {
                    return params.join('.');
                }
                return field.functionName;
            }
            case 'FieldRelationship': {
                var firstRelationship = field.relationships[0].toLowerCase();
                if (hasAlias(field)) {
                    return field.alias;
                }
                if (field.rawValue && groupByFields[field.rawValue.toLocaleLowerCase()]) {
                    return field.field;
                }
                if (firstRelationship === sObjectAlias || firstRelationship === sObject) {
                    return field.relationships.concat([field.field]).slice(1).join('.');
                }
                return field.relationships.concat([field.field]).join('.');
            }
            case 'FieldSubquery': {
                return field.subquery.relationshipName;
            }
            case 'FieldTypeof': {
                var priorFields_1 = new Set();
                var fields_1 = [];
                field.conditions.forEach(function (condition) {
                    condition.fieldList.forEach(function (currField) {
                        if (!priorFields_1.has(currField)) {
                            priorFields_1.add(currField);
                            fields_1.push(field.field + "." + currField);
                        }
                    });
                });
                return fields_1;
            }
            default:
                break;
        }
    })
        .filter(function (field) { return isString(field); });
    return parsedFields;
}
//# sourceMappingURL=public-utils.js.map