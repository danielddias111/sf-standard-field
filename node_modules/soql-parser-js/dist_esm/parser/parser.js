var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { CstParser } from 'chevrotain';
import * as lexer from './lexer';
var LexingError = (function (_super) {
    __extends(LexingError, _super);
    function LexingError(lexingError) {
        var _this = _super.call(this, lexingError.message + " (" + lexingError.line + ":" + lexingError.column + ")") || this;
        _this.name = 'LexingError';
        return _this;
    }
    return LexingError;
}(Error));
var ParsingError = (function (_super) {
    __extends(ParsingError, _super);
    function ParsingError(parsingError) {
        var _this = _super.call(this, parsingError.message) || this;
        _this.name = parsingError.name;
        return _this;
    }
    return ParsingError;
}(Error));
var SoqlParser = (function (_super) {
    __extends(SoqlParser, _super);
    function SoqlParser() {
        var _this = _super.call(this, lexer.allTokens, {
            skipValidations: false,
        }) || this;
        _this.$_dateFunctionOr = undefined;
        _this.$_aggregateFunction = undefined;
        _this.$_otherFunction = undefined;
        _this.$_atomicExpression = undefined;
        _this.$_arrayExpression = undefined;
        _this.$_relationalOperator = undefined;
        _this.$_selectClause = undefined;
        _this.$_selectClauseFunctionIdentifier = undefined;
        _this.$_withDataCategoryArr = undefined;
        _this.allowApexBindVariables = false;
        _this.selectStatement = _this.RULE('selectStatement', function () {
            _this.SUBRULE(_this.selectClause);
            _this.SUBRULE(_this.fromClause);
            _this.OPTION(function () {
                _this.SUBRULE(_this.usingScopeClause);
            });
            _this.OPTION1(function () {
                _this.SUBRULE(_this.whereClause);
            });
            _this.OPTION2(function () {
                _this.MANY({
                    DEF: function () {
                        _this.SUBRULE(_this.withClause);
                    },
                });
            });
            _this.OPTION3(function () {
                _this.SUBRULE(_this.groupByClause);
                _this.OPTION4(function () {
                    _this.SUBRULE(_this.havingClause);
                });
            });
            _this.OPTION5(function () {
                _this.SUBRULE(_this.orderByClause);
            });
            _this.OPTION6(function () {
                _this.SUBRULE(_this.limitClause);
            });
            _this.OPTION7(function () {
                _this.SUBRULE(_this.offsetClause);
            });
            _this.OPTION8(function () {
                _this.SUBRULE(_this.forViewOrReference);
            });
            _this.OPTION9(function () {
                _this.SUBRULE(_this.updateTrackingViewstat);
            });
        });
        _this.selectClause = _this.RULE('selectClause', function () {
            _this.CONSUME(lexer.Select);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.OR(_this.$_selectClause ||
                        (_this.$_selectClause = [
                            { ALT: function () { return _this.SUBRULE(_this.selectClauseFunctionIdentifier, { LABEL: 'field' }); } },
                            { ALT: function () { return _this.SUBRULE(_this.selectClauseSubqueryIdentifier, { LABEL: 'field' }); } },
                            { ALT: function () { return _this.SUBRULE(_this.selectClauseTypeOf, { LABEL: 'field' }); } },
                            { ALT: function () { return _this.SUBRULE(_this.selectClauseIdentifier, { LABEL: 'field' }); } },
                        ]));
                },
            });
        });
        _this.selectClauseFunctionIdentifier = _this.RULE('selectClauseFunctionIdentifier', function () {
            _this.OR(_this.$_selectClauseFunctionIdentifier ||
                (_this.$_selectClauseFunctionIdentifier = [
                    { ALT: function () { return _this.SUBRULE(_this.dateFunction, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.SUBRULE(_this.aggregateFunction, { LABEL: 'fn', ARGS: [true] }); } },
                    { ALT: function () { return _this.SUBRULE(_this.locationFunction, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.SUBRULE(_this.fieldsFunction, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.SUBRULE(_this.otherFunction, { LABEL: 'fn' }); } },
                ]));
            _this.OPTION(function () { return _this.CONSUME(lexer.Identifier, { LABEL: 'alias' }); });
        });
        _this.selectClauseSubqueryIdentifier = _this.RULE('selectClauseSubqueryIdentifier', function () {
            _this.CONSUME(lexer.LParen);
            _this.SUBRULE(_this.selectStatement);
            _this.CONSUME(lexer.RParen);
        });
        _this.selectClauseTypeOf = _this.RULE('selectClauseTypeOf', function () {
            _this.CONSUME(lexer.Typeof);
            _this.CONSUME(lexer.Identifier, { LABEL: 'typeOfField' });
            _this.AT_LEAST_ONE({
                DEF: function () {
                    _this.SUBRULE(_this.selectClauseTypeOfThen);
                },
            });
            _this.OPTION(function () {
                _this.SUBRULE(_this.selectClauseTypeOfElse);
            });
            _this.CONSUME(lexer.End);
        });
        _this.selectClauseIdentifier = _this.RULE('selectClauseIdentifier', function () {
            _this.CONSUME(lexer.Identifier, { LABEL: 'field' });
            _this.OPTION(function () { return _this.CONSUME1(lexer.Identifier, { LABEL: 'alias' }); });
        });
        _this.selectClauseTypeOfThen = _this.RULE('selectClauseTypeOfThen', function () {
            _this.CONSUME(lexer.When);
            _this.CONSUME(lexer.Identifier, { LABEL: 'typeOfField' });
            _this.CONSUME(lexer.Then);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.CONSUME1(lexer.Identifier, { LABEL: 'field' });
                },
            });
        });
        _this.selectClauseTypeOfElse = _this.RULE('selectClauseTypeOfElse', function () {
            _this.CONSUME(lexer.Else);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.CONSUME(lexer.Identifier, { LABEL: 'field' });
                },
            });
        });
        _this.fromClause = _this.RULE('fromClause', function () {
            _this.CONSUME(lexer.From);
            _this.CONSUME(lexer.Identifier);
            _this.OPTION({
                GATE: function () { return !(_this.LA(1).tokenType === lexer.Offset && _this.LA(2).tokenType === lexer.UnsignedInteger); },
                DEF: function () { return _this.CONSUME1(lexer.Identifier, { LABEL: 'alias' }); },
            });
        });
        _this.usingScopeClause = _this.RULE('usingScopeClause', function () {
            _this.CONSUME(lexer.Using);
            _this.CONSUME(lexer.Scope);
            _this.CONSUME(lexer.UsingScopeEnumeration);
        });
        _this.whereClause = _this.RULE('whereClause', function () {
            _this.CONSUME(lexer.Where);
            var parenCount = _this.getParenCount();
            _this.AT_LEAST_ONE({
                DEF: function () {
                    _this.SUBRULE(_this.conditionExpression, { ARGS: [parenCount, false, true, true] });
                },
            });
            _this.$_checkBalancedParens(parenCount);
        });
        _this.whereClauseSubqueryIdentifier = _this.RULE('whereClauseSubqueryIdentifier', function () {
            _this.CONSUME(lexer.LParen);
            _this.SUBRULE(_this.selectStatement);
            _this.CONSUME(lexer.RParen);
        });
        _this.conditionExpression = _this.RULE('conditionExpression', function (parenCount, allowSubquery, alowAggregateFn, allowLocationFn) {
            parenCount = _this.getParenCount(parenCount);
            _this.OPTION(function () {
                _this.OR([
                    { ALT: function () { return _this.CONSUME(lexer.And, { LABEL: 'logicalOperator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Or, { LABEL: 'logicalOperator' }); } },
                ]);
            });
            _this.MANY({
                MAX_LOOKAHEAD: 10,
                DEF: function () { return _this.SUBRULE(_this.expressionPartWithNegation, { ARGS: [parenCount], LABEL: 'expressionNegation' }); },
            });
            _this.OR1({
                MAX_LOOKAHEAD: 10,
                DEF: [{ ALT: function () { return _this.SUBRULE(_this.expression, { ARGS: [parenCount, allowSubquery, alowAggregateFn, allowLocationFn] }); } }],
            });
        });
        _this.withClause = _this.RULE('withClause', function () {
            _this.CONSUME(lexer.With);
            _this.OR([
                { ALT: function () { return _this.CONSUME(lexer.SecurityEnforced, { LABEL: 'withSecurityEnforced' }); } },
                { ALT: function () { return _this.SUBRULE(_this.withDataCategory); } },
            ]);
        });
        _this.withDataCategory = _this.RULE('withDataCategory', function () {
            _this.CONSUME(lexer.DataCategory);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.And,
                DEF: function () {
                    _this.SUBRULE(_this.withDataCategoryArr);
                },
            });
        });
        _this.withDataCategoryArr = _this.RULE('withDataCategoryArr', function () {
            _this.CONSUME(lexer.Identifier, { LABEL: 'dataCategoryGroupName' });
            _this.OR(_this.$_withDataCategoryArr ||
                (_this.$_withDataCategoryArr = [
                    { ALT: function () { return _this.CONSUME(lexer.At, { LABEL: 'filteringSelector' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Above, { LABEL: 'filteringSelector' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Below, { LABEL: 'filteringSelector' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.AboveOrBelow, { LABEL: 'filteringSelector' }); } },
                ]));
            _this.OPTION(function () {
                _this.CONSUME1(lexer.LParen);
            });
            _this.AT_LEAST_ONE_SEP1({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.CONSUME1(lexer.Identifier, { LABEL: 'dataCategoryName' });
                },
            });
            _this.OPTION1(function () {
                _this.CONSUME2(lexer.RParen);
            });
        });
        _this.groupByClause = _this.RULE('groupByClause', function () {
            _this.CONSUME(lexer.GroupBy);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.OR([
                        { ALT: function () { return _this.SUBRULE(_this.cubeFunction, { LABEL: 'groupBy' }); } },
                        { ALT: function () { return _this.SUBRULE(_this.rollupFunction, { LABEL: 'groupBy' }); } },
                        { ALT: function () { return _this.SUBRULE(_this.dateFunction, { LABEL: 'groupBy' }); } },
                        { ALT: function () { return _this.CONSUME(lexer.Identifier, { LABEL: 'groupBy' }); } },
                    ]);
                },
            });
        });
        _this.havingClause = _this.RULE('havingClause', function () {
            _this.CONSUME(lexer.Having);
            var parenCount = _this.getParenCount();
            _this.AT_LEAST_ONE({
                DEF: function () {
                    _this.SUBRULE(_this.conditionExpression, { ARGS: [parenCount, true] });
                },
            });
            _this.$_checkBalancedParens(parenCount);
        });
        _this.orderByClause = _this.RULE('orderByClause', function () {
            _this.CONSUME(lexer.OrderBy);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.OR([
                        { ALT: function () { return _this.SUBRULE(_this.orderByGroupingFunctionExpression, { LABEL: 'orderByExpressionOrFn' }); } },
                        { ALT: function () { return _this.SUBRULE(_this.orderBySpecialFunctionExpression, { LABEL: 'orderByExpressionOrFn' }); } },
                        { ALT: function () { return _this.SUBRULE(_this.orderByExpression, { LABEL: 'orderByExpressionOrFn' }); } },
                    ]);
                },
            });
        });
        _this.orderByExpression = _this.RULE('orderByExpression', function () {
            _this.CONSUME(lexer.Identifier);
            _this.OPTION(function () {
                _this.OR([{ ALT: function () { return _this.CONSUME(lexer.Asc, { LABEL: 'order' }); } }, { ALT: function () { return _this.CONSUME(lexer.Desc, { LABEL: 'order' }); } }]);
            });
            _this.OPTION1(function () {
                _this.CONSUME(lexer.Nulls);
                _this.OR1([{ ALT: function () { return _this.CONSUME(lexer.First, { LABEL: 'nulls' }); } }, { ALT: function () { return _this.CONSUME(lexer.Last, { LABEL: 'nulls' }); } }]);
            });
        });
        _this.orderByGroupingFunctionExpression = _this.RULE('orderByGroupingFunctionExpression', function () {
            _this.CONSUME(lexer.Grouping, { LABEL: 'fn' });
            _this.SUBRULE(_this.functionExpression);
        });
        _this.orderBySpecialFunctionExpression = _this.RULE('orderBySpecialFunctionExpression', function () {
            _this.OR([
                { ALT: function () { return _this.SUBRULE(_this.aggregateFunction); } },
                { ALT: function () { return _this.SUBRULE(_this.dateFunction); } },
                { ALT: function () { return _this.SUBRULE(_this.locationFunction); } },
            ]);
            _this.OPTION(function () {
                _this.OR1([{ ALT: function () { return _this.CONSUME(lexer.Asc, { LABEL: 'order' }); } }, { ALT: function () { return _this.CONSUME(lexer.Desc, { LABEL: 'order' }); } }]);
            });
            _this.OPTION1(function () {
                _this.CONSUME(lexer.Nulls);
                _this.OR2([{ ALT: function () { return _this.CONSUME(lexer.First, { LABEL: 'nulls' }); } }, { ALT: function () { return _this.CONSUME(lexer.Last, { LABEL: 'nulls' }); } }]);
            });
        });
        _this.limitClause = _this.RULE('limitClause', function () {
            _this.CONSUME(lexer.Limit);
            _this.CONSUME(lexer.UnsignedInteger, { LABEL: 'value' });
        });
        _this.offsetClause = _this.RULE('offsetClause', function () {
            _this.CONSUME(lexer.Offset);
            _this.CONSUME(lexer.UnsignedInteger, { LABEL: 'value' });
        });
        _this.dateFunction = _this.RULE('dateFunction', function () {
            _this.OR(_this.$_dateFunctionOr ||
                (_this.$_dateFunctionOr = [
                    { ALT: function () { return _this.CONSUME(lexer.CalendarMonth, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.CalendarQuarter, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.CalendarYear, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.DayInMonth, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.DayInWeek, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.DayInYear, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.DayOnly, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.FiscalMonth, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.FiscalQuarter, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.FiscalYear, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.HourInDay, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.WeekInMonth, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.WeekInYear, { LABEL: 'fn' }); } },
                ]));
            _this.SUBRULE(_this.functionExpression);
        });
        _this.aggregateFunction = _this.RULE('aggregateFunction', function () {
            _this.OR(_this.$_aggregateFunction ||
                (_this.$_aggregateFunction = [
                    { ALT: function () { return _this.CONSUME(lexer.Avg, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Count, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.CountDistinct, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Min, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Max, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Sum, { LABEL: 'fn' }); } },
                ]));
            _this.SUBRULE(_this.functionExpression, { ARGS: [true] });
        });
        _this.fieldsFunction = _this.RULE('fieldsFunction', function () {
            _this.CONSUME(lexer.Fields, { LABEL: 'fn' });
            _this.CONSUME(lexer.LParen);
            _this.CONSUME(lexer.FieldsFunctionParamIdentifier, { LABEL: 'params' });
            _this.CONSUME(lexer.RParen);
        });
        _this.otherFunction = _this.RULE('otherFunction', function () {
            _this.OR(_this.$_otherFunction ||
                (_this.$_otherFunction = [
                    { ALT: function () { return _this.CONSUME(lexer.Format, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Tolabel, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.ConvertTimeZone, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.ConvertCurrency, { LABEL: 'fn' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Grouping, { LABEL: 'fn' }); } },
                ]));
            _this.SUBRULE(_this.functionExpression);
        });
        _this.cubeFunction = _this.RULE('cubeFunction', function () {
            _this.CONSUME(lexer.Cube, { LABEL: 'fn' });
            _this.SUBRULE(_this.functionExpression);
        });
        _this.rollupFunction = _this.RULE('rollupFunction', function () {
            _this.CONSUME(lexer.Rollup, { LABEL: 'fn' });
            _this.SUBRULE(_this.functionExpression);
        });
        _this.functionExpression = _this.RULE('functionExpression', function (skipAggregate) {
            _this.CONSUME(lexer.LParen);
            _this.MANY_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.OR([
                        { GATE: function () { return !skipAggregate; }, ALT: function () { return _this.SUBRULE(_this.aggregateFunction, { LABEL: 'params' }); } },
                        { ALT: function () { return _this.SUBRULE(_this.otherFunction, { LABEL: 'params' }); } },
                        { ALT: function () { return _this.CONSUME(lexer.StringIdentifier, { LABEL: 'params' }); } },
                        { ALT: function () { return _this.CONSUME(lexer.NumberIdentifier, { LABEL: 'params' }); } },
                        { ALT: function () { return _this.CONSUME(lexer.Identifier, { LABEL: 'params' }); } },
                    ]);
                },
            });
            _this.CONSUME(lexer.RParen);
        });
        _this.locationFunction = _this.RULE('locationFunction', function () {
            _this.CONSUME(lexer.Distance);
            _this.CONSUME(lexer.LParen);
            _this.CONSUME(lexer.Identifier, { LABEL: 'location1' });
            _this.CONSUME(lexer.Comma);
            _this.OR([
                { ALT: function () { return _this.SUBRULE(_this.geolocationFunction, { LABEL: 'location2' }); } },
                { ALT: function () { return _this.CONSUME1(lexer.Identifier, { LABEL: 'location2' }); } },
            ]);
            _this.CONSUME1(lexer.Comma);
            _this.CONSUME(lexer.GeolocationUnit, { LABEL: 'unit' });
            _this.CONSUME(lexer.RParen);
        });
        _this.geolocationFunction = _this.RULE('geolocationFunction', function () {
            _this.CONSUME(lexer.Geolocation);
            _this.CONSUME(lexer.LParen);
            _this.CONSUME(lexer.NumberIdentifier, { LABEL: 'latitude' });
            _this.CONSUME(lexer.Comma);
            _this.CONSUME1(lexer.NumberIdentifier, { LABEL: 'longitude' });
            _this.CONSUME(lexer.RParen);
        });
        _this.expressionPartWithNegation = _this.RULE('expressionPartWithNegation', function (parenCount) {
            var leftParenCount = 0;
            _this.MANY(function () {
                _this.CONSUME(lexer.LParen);
                leftParenCount++;
            });
            _this.CONSUME(lexer.Not, { LABEL: 'expressionNegation' });
            if (parenCount && leftParenCount) {
                parenCount.left += leftParenCount;
            }
        });
        _this.expression = _this.RULE('expression', function (parenCount, allowSubquery, alowAggregateFn, allowLocationFn) {
            _this.OPTION1(function () {
                _this.MANY1(function () {
                    _this.CONSUME(lexer.LParen);
                    if (parenCount) {
                        parenCount.left++;
                    }
                });
            });
            _this.OR1([
                { GATE: function () { return alowAggregateFn; }, ALT: function () { return _this.SUBRULE(_this.aggregateFunction, { LABEL: 'lhs' }); } },
                { GATE: function () { return allowLocationFn; }, ALT: function () { return _this.SUBRULE(_this.locationFunction, { LABEL: 'lhs' }); } },
                { ALT: function () { return _this.SUBRULE(_this.dateFunction, { LABEL: 'lhs' }); } },
                { ALT: function () { return _this.SUBRULE(_this.otherFunction, { LABEL: 'lhs' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Identifier, { LABEL: 'lhs' }); } },
            ]);
            _this.OR2([
                { ALT: function () { return _this.SUBRULE(_this.expressionWithRelationalOperator, { LABEL: 'operator' }); } },
                { ALT: function () { return _this.SUBRULE(_this.expressionWithSetOperator, { LABEL: 'operator', ARGS: [allowSubquery] }); } },
            ]);
            _this.OPTION3(function () {
                _this.MANY2({
                    GATE: function () { return (parenCount ? parenCount.left > parenCount.right : true); },
                    DEF: function () {
                        _this.CONSUME(lexer.RParen);
                        if (parenCount) {
                            parenCount.right++;
                        }
                    },
                });
            });
        });
        _this.expressionWithRelationalOperator = _this.RULE('expressionWithRelationalOperator', function () {
            _this.SUBRULE(_this.relationalOperator);
            _this.SUBRULE(_this.atomicExpression, { LABEL: 'rhs' });
        });
        _this.expressionWithSetOperator = _this.RULE('expressionWithSetOperator', function (allowSubquery) {
            _this.SUBRULE(_this.setOperator);
            _this.SUBRULE2(_this.atomicExpression, { LABEL: 'rhs', ARGS: [true, allowSubquery] });
        });
        _this.atomicExpression = _this.RULE('atomicExpression', function (isArray, allowSubquery) {
            _this.OR(_this.$_atomicExpression ||
                (_this.$_atomicExpression = [
                    { GATE: function () { return _this.allowApexBindVariables; }, ALT: function () { return _this.SUBRULE(_this.apexBindVariableExpression); } },
                    { GATE: function () { return isArray; }, ALT: function () { return _this.SUBRULE(_this.arrayExpression); } },
                    { GATE: function () { return isArray && allowSubquery; }, ALT: function () { return _this.SUBRULE(_this.whereClauseSubqueryIdentifier); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.DateIdentifier); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.CurrencyPrefixedDecimal, { LABEL: 'CurrencyPrefixedDecimal' }); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.CurrencyPrefixedInteger, { LABEL: 'CurrencyPrefixedInteger' }); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.NumberIdentifier); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.Null); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.SUBRULE(_this.booleanValue); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.DateLiteral); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.SUBRULE(_this.dateNLiteral); } },
                    { GATE: function () { return !isArray; }, ALT: function () { return _this.CONSUME(lexer.StringIdentifier); } },
                ]));
        });
        _this.apexBindVariableExpression = _this.RULE('apexBindVariableExpression', function () {
            _this.CONSUME(lexer.Colon);
            _this.CONSUME(lexer.Identifier);
        });
        _this.arrayExpression = _this.RULE('arrayExpression', function () {
            _this.CONSUME(lexer.LParen);
            _this.AT_LEAST_ONE_SEP({
                SEP: lexer.Comma,
                DEF: function () {
                    _this.OR(_this.$_arrayExpression ||
                        (_this.$_arrayExpression = [
                            { ALT: function () { return _this.CONSUME(lexer.CurrencyPrefixedDecimal, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.CurrencyPrefixedInteger, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.NumberIdentifier, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.DateIdentifier, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.Null, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.True, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.False, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.DateLiteral, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.SUBRULE(_this.dateNLiteral, { LABEL: 'value' }); } },
                            { ALT: function () { return _this.CONSUME(lexer.StringIdentifier, { LABEL: 'value' }); } },
                        ]));
                },
            });
            _this.CONSUME(lexer.RParen);
        });
        _this.relationalOperator = _this.RULE('relationalOperator', function () {
            _this.OR(_this.$_relationalOperator ||
                (_this.$_relationalOperator = [
                    { ALT: function () { return _this.CONSUME(lexer.Equal, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.NotEqual, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.GreaterThan, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.GreaterThanOrEqual, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.LessThan, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.LessThanOrEqual, { LABEL: 'operator' }); } },
                    { ALT: function () { return _this.CONSUME(lexer.Like, { LABEL: 'operator' }); } },
                ]));
        });
        _this.setOperator = _this.RULE('setOperator', function () {
            _this.OR([
                { ALT: function () { return _this.CONSUME(lexer.In, { LABEL: 'operator' }); } },
                { ALT: function () { return _this.CONSUME(lexer.NotIn, { LABEL: 'operator' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Includes, { LABEL: 'operator' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Excludes, { LABEL: 'operator' }); } },
            ]);
        });
        _this.booleanValue = _this.RULE('booleanValue', function () {
            _this.OR([
                { ALT: function () { return _this.CONSUME(lexer.True, { LABEL: 'boolean' }); } },
                { ALT: function () { return _this.CONSUME(lexer.False, { LABEL: 'boolean' }); } },
            ]);
        });
        _this.dateNLiteral = _this.RULE('dateNLiteral', function () {
            _this.CONSUME(lexer.DateNLiteral, { LABEL: 'dateNLiteral' });
            _this.CONSUME(lexer.Colon);
            _this.OR1([
                { ALT: function () { return _this.CONSUME(lexer.UnsignedInteger, { LABEL: 'variable' }); } },
                { ALT: function () { return _this.CONSUME(lexer.SignedInteger, { LABEL: 'variable' }); } },
            ]);
        });
        _this.forViewOrReference = _this.RULE('forViewOrReference', function () {
            _this.CONSUME(lexer.For);
            _this.OR([
                { ALT: function () { return _this.CONSUME(lexer.View, { LABEL: 'value' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Reference, { LABEL: 'value' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Update, { LABEL: 'value' }); } },
            ]);
        });
        _this.updateTrackingViewstat = _this.RULE('updateTrackingViewstat', function () {
            _this.CONSUME(lexer.Update);
            _this.OR([
                { ALT: function () { return _this.CONSUME(lexer.Tracking, { LABEL: 'value' }); } },
                { ALT: function () { return _this.CONSUME(lexer.Viewstat, { LABEL: 'value' }); } },
            ]);
        });
        _this.performSelfAnalysis();
        return _this;
    }
    SoqlParser.prototype.$_checkBalancedParens = function (parenCount) {
        if (!this.RECORDING_PHASE && parenCount) {
            var parenMatch = parenCount.left - parenCount.right;
            if (parenMatch !== 0) {
                this.CONSUME(lexer.RParenMismatch, { ERR_MSG: "Expecting a token type of --> RParen <-- but found --> '' <--" });
            }
        }
    };
    SoqlParser.prototype.getParenCount = function (parenCount) {
        return parenCount || { right: 0, left: 0 };
    };
    return SoqlParser;
}(CstParser));
export { SoqlParser };
var parser = new SoqlParser();
export function parse(soql, options) {
    options = options || { allowApexBindVariables: false, logErrors: false };
    var lexResult = lexer.lex(soql);
    if (lexResult.errors.length > 0) {
        if (options.logErrors) {
            console.log('Lexing Errors:');
            console.log(lexResult.errors);
        }
        throw new LexingError(lexResult.errors[0]);
    }
    parser.input = lexResult.tokens;
    parser.allowApexBindVariables = options.allowApexBindVariables || false;
    var cst = parser.selectStatement();
    if (parser.errors.length > 0) {
        if (options.logErrors) {
            console.log('Parsing Errors:');
            console.log(parser.errors);
        }
        throw new ParsingError(parser.errors[0]);
    }
    return cst;
}
//# sourceMappingURL=parser.js.map